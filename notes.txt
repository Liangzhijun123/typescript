-- Chapter 1 --

-to run the typescript type 'tsc main.ts -w' continue to watch main.ts for any changes

1: 'tsc main.ts'
2: click go live server in vscode at the bottom
3: 'tsc main.ts -w' in order to recompile JS so it watch if the file is changed

File structure 
-build (HTML, CSS, JS, nested directory)
-src (raw files, components, Typescript)

4:'tsc --init' to initalize the file

5: uncomment "rootDir": "./src" in tsconfig.json file
  uncomment "outDir": "./build/js", 
  -'./src' because it is where typscript file will be
  -'./build/js' so now JS can compile here

6: tsc -w will now look for all the files in the directories

'"target": "es2016", ' recompile JS variables to be 'let' instead of 'var'

If i want to delete a file in 'ts' you have to delete 'js' too
If you put a ts file in the root (dont do it), it also compile the js in the root 

scroll down to end of tsconfig.json and include 
  - "include": [
    "src"
  ]
  -now when you creat a file in root it doesn't pop out the js file

-uncomment out '"noEmitOnError": true,' in tsconfig.json it lets JS compile or typescript error
-comment out '"noEmitOnError": true,' so we can see the typescript error

 
// defind a user name. if we run both files main.ts and main.js we get error.
// if we chane the string to something else it won't work because it needs to recompile in main.js
let username = 'alice';
console.log(username);

// typescript need  ':number/string' to indicate what it is
let a: number = 12;
let b: number =6;
let c: number = 2;

// this is a valid JS code but ts dont like it. can't mulitple string with number
console.log(a / b);

// typescrip doesn't get in JS way
console.log(c * b);


-- Chapter 2 --

-Static typing and dynamic typing is not the same as strongly type

-A language that is strongly typed can be either statically or dynamic typed

-TS is a static type language. types are checked at compile time.
-JS is dynamic type language. types are checked at run time 

-TS infer
  -implicitly shown. not restricted what it is
  -explicitly state that the varible is what type

  ex:
    // if mouse over this it will say 'let myName :string'. 
    // implicitly -> not shown the type
    let myName = 'Dave'

    // explicitly -> no longer inferring because we declare it is a string
    let myName: string = 'Dave'

let myName: string = 'John';
let meaningOfLife: number;
let isLoading: boolean;

// 'any' can be any data types
let album: any;

// union type. string or number -> either one is ok
let wallet: string | number;

let postID: string | number;

// can be more than two types
let isActive: number | boolean | string;

// basic expression to select all words
let regular_Expression: RegExp = /\w+/g;

myName = 'Dave';
meaningOfLife = 42;
isLoading = true;
album = 'van halen';

// function
const sum = (a: number, b: string) => {
    return a + b;
}



-- Chapter 3 --

Array and Objects

let stringArr: string[] = ['one','hey','dave'];

let guitars: (string | number)[] = ['strat','les paul', 5150];

let mixedDate: (string | number | boolean)[] = ['evh', 1984, true];

stringArr[0] = 'hey';
stringArr.push('jasmine');

guitars[0] = 1984;

// unshift -> add to beginning of array
guitars.unshift('jim');

guitars = stringArr;
mixedDate = guitars;

let bands: string[] = []
bands.push('van halen')

// Tuple 
// this is strict because it limits how much to be put here
let myTuple: [string, number, boolean] = ['dave', 42,true];

// union type with string, number, boolean
let mixed = ['john',1,false];

// mixed is a type of array with union array that accepts string number and boolean
// can't do mytuple = mixed because the target requires 3 elements.cant assign tuples that requires 3 elements 
mixed = myTuple;

// Objects
let myObj: object;
myObj = [];
console.log(typeof myObj);
myObj = bands;

const exampleObj = {
    prop1: 'dave',
    prop2:true,
}

exampleObj.prop1 = 'john';

// annotate a type. interface is or define a class and methods are inside. can use type = {} too! they both works the same
interface Guitarist  {
    name: string,

    // property optional when you put '?' before the call
    active?: boolean,

    albums: (string | number)[],
}

// evh is Guitarist type. cannot omit because it gives error
let evh: Guitarist = {
    name: 'eddie',
    active: false,
    albums: [1984, 5150,'OU812'],
}

let jp: Guitarist = {
    name: 'jimmy',
    active: true,
    albums: ['I','II','IV'],
}

// evh and jp are same annotate type
evh = jp

// how to make property optional
let vh: Guitarist = {
    // now when i delete a property in here with Guitarist it no have error because 'active' is optional property type
    name: 'jimmy',   
    albums: ['I','II','IV'],
}

// both are Guitarist
evh = jp

// make a funation to test out. 
const greetGuitarist = (guitarist: Guitarist) => {

    if (guitarist.name){

        // if the Guitarist have a name it will return
        return `hello  ${guitarist.name}!`;
    }

    // if the GUitarist doesn't have a name it will return
    return 'hello! Missing name';
    
}
console.log(greetGuitarist(jp));

// Enums

/* 
Enums are not a type level addition to JS but something added to the language and runtime
*/

// enums start a position 0. if change values, TS will keep in order
enum Grade {

    // change values
    U = 1,
    D,
    C,
    B,
    A,
}

console.log(Grade.U);


-- Chapter 4 --

// type aliases
type stringOrNumber = string | number;

type stringOrNumberArray = (string | number) [];

type Guitarist = {
    name?: string,

    // property optional when you put '?' before the call
    active: boolean,

    albums: stringOrNumberArray,
}

type UserId = stringOrNumber;

// literaly types
let myName: 'dave';

let userName: 'dave' | 'john' | 'amy';
userName = 'amy';

// functions
const add = (a: number , b: number): number => {
    return a + b;
}

const logMsg = (message: any) =>{
    console.log(message);
}

logMsg ('hello');
logMsg(add(2,3));

let subtract = function (c: number , d: number): number{
    return c - d;
}

// type mathFunction = (a: number , b: number) => number;
interface mathFunction {
    (a: number , b: number) : number;
} 

let multiply: mathFunction = function (c,d){
    return c * d;
}

logMsg(multiply(2,2));

// optional parameters comes at last onlu
const addAll = (a: number, b: number, c?: number) : number => {

    // if type c is not undefine it will add a + b + c
    if (typeof c !== 'undefined'){
        return a + b + c;
    }

    // if type c is undefine it will add a + b
    return a + b;
}

// assign default values
const sumAll = (a: number = 10, b: number, c: number = 2 ) : number => {

    return a + b + c;
}

logMsg(addAll(2,3,2));
logMsg(addAll(2,3));
logMsg(sumAll(2,3));

// to skip value a but it will still have default value
logMsg(sumAll(undefined,3));

// rest parameters. ...nums is for you don't know how many values you put in
const total = (a: number , ...nums: number[]): number => {
    return a + nums.reduce((prev, curr) => prev + curr);
} 
logMsg(total(10,2,3));

// never type
const createEroor = (errMsg: string) => {
    throw new Error(errMsg);
}

// endless error so you need a if and else otherwise is endless loop
const infinite = () => {
    let i: number = 1;
    while (true){
        i++;
        if( i > 100 ) break;
    }
}

// custom type guard
const isNumber = (value: any): boolean => {
    return typeof value === 'number' 
    ? true : false;
}

// to use never type
const numberOrString = (value: number | string) : string => {
    if (typeof value === 'string') return 'string';
    if (isNumber(value)) return 'number';
    return createEroor('this should never happen!');
}

-- Chapter 5 --
Assertions

-information like 'document.' is a type of value that TS dont know.
    -TS will return HTMLElement given an postID

